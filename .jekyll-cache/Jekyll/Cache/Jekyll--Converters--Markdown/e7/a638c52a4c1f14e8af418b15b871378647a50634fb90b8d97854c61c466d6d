I"ì/<p>We all love closures, don‚Äôt we? Closures make an iOS developer‚Äôs life easy. Well, if it makes it easy, then why am I saying to avoid using closures in Swift structs? The reason is, ‚ÄúMemory leaks and unexpected behaviors.‚Äù
Wait. What? Memory leak in structs? How could that be possible?</p>

<div>
    <a class="notification sponsor" href="https://winya.link/get" target="_blank">
    <img src="https://ik.imagekit.io/cfsimagecdn/Winya/winya_512_qKON5oTjw.png" />
    <div>
    <p class="sponsor-title">
        Winya: Best screen sharing app for iPhone/iPad
    </p>
    <p>
        Become a Streamer by starting a live stream from your iPhone/iPad to Twitch/YouTube or any live streaming service of your choice. Download the app and become a creator now!</p>
    </div>
</a>
</div>

<p><img src="/blog/assets/images/closuresinstructs.png" alt="Why should we avoid using closures in Swift structs?" /></p>

<p>Structs are value types, and there is no way a memory leak can occur.
Is that statement even true? We have so many questions already. So let‚Äôs get back to the basics of memory management in Swift.</p>

<h2 id="back-to-basics"><strong>Back to basics</strong></h2>

<p>The reason I am taking you back to the basics is that before diving into the main problem, we need to have a stronghold of the basics.</p>

<p>The basic types in Swift fall into two categories. One is the ‚ÄúReference type,‚Äù and the other is the ‚ÄúValue type.‚Äù Generally, Classes are reference types. On the other hand, structs and enums are value types.</p>

<h2 id="value-types"><strong>Value types</strong></h2>

<p>The value types store the data directly in memory. Every instance has a unique copy of the data. When a variable is assigned to an existing variable, the data is copied. The allocation of the value types is done in the stack. When the value type variable goes out of scope, the deallocation of the memory occurs.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Person</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">name</span> <span class="p">:</span> <span class="kt">String</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">oldPerson</span> <span class="o">=</span> <span class="kt">Person</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"Rizwan"</span><span class="p">)</span>
<span class="k">var</span> <span class="nv">newPerson</span> <span class="o">=</span> <span class="n">oldPerson</span>
<span class="n">newPerson</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">"Oh my Swift"</span>
<span class="nf">print</span><span class="p">(</span><span class="n">oldPerson</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">newPerson</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

<span class="o">-------</span>
<span class="kt">Output</span><span class="p">:</span>
<span class="kt">Rizwan</span>
<span class="kt">Oh</span> <span class="n">my</span> <span class="kt">Swift</span>
<span class="o">-------</span>
</code></pre></div></div>

<p>We can see that changing the value of the newPerson doesn‚Äôt change the value of oldPerson. This is how value types work.</p>

<h2 id="reference-types"><strong>Reference types</strong></h2>

<p>The reference types keep a reference (aka a pointer) to the data when initialized. Whenever a variable is assigned to an existing reference type, the reference is shared among the variables. The allocation of reference types is done in the heap. The ARC (Automatic Reference Counting) handles the deallocation of the reference type variables.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">Person</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span>
    <span class="nf">init</span><span class="p">(</span><span class="n">withName</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span><span class="p">){</span>
        <span class="k">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">oldPerson</span> <span class="o">=</span> <span class="kt">Person</span><span class="p">(</span><span class="nv">withName</span><span class="p">:</span> <span class="s">"Rizwan"</span><span class="p">)</span>
<span class="k">var</span> <span class="nv">newPerson</span> <span class="o">=</span> <span class="n">oldPerson</span>
<span class="n">newPerson</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">"Oh my Swift"</span>
<span class="nf">print</span><span class="p">(</span><span class="n">oldPerson</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">newPerson</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>


<span class="o">------</span>
<span class="kt">Output</span>
<span class="kt">Oh</span> <span class="n">my</span> <span class="kt">Swift</span>
<span class="kt">Oh</span> <span class="n">my</span> <span class="kt">Swift</span>
<span class="o">------</span>
</code></pre></div></div>

<p>We can see that changing the oldPerson variable reflects the changes in the newPerson variable. This is how reference types work.</p>

<p>Usually, memory leaks occur in reference types. It occurs in the form of retain cycles in most of the cases. To know more about retain cycles, read this <a href="https://medium.com/flawless-app-stories/memory-leaks-in-swift-bfd5f95f3a74">blog</a> from Flawless app stories.</p>

<p>So, if reference types are the reason for memory leaks, we can use value types for all purposes. That should solve the problem.</p>

<p>Unfortunately, this is not the case. Sometimes structs and enums can be treated as reference types, and this means that retain cycles can occur in structs and enums too.</p>

<h2 id="closures---the-villain-in-structs"><strong>Closures - The Villain in structs</strong></h2>

<p>When you use closures in structs, the closure behaves as a reference type, and the problem starts there. The closures need to have a reference to the environment outside so that the environment can be modified when the closure body is executed.</p>

<p>In the case of classes, we can use <code class="language-plaintext highlighter-rouge">weak self</code> to break the retain cycle. When we try to do it for a struct, we get the following compiler error, ‚Äòweak‚Äô may only be applied to class and class-bound protocol types, not ‚Äò{struct name}‚Äô</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Car</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">speed</span><span class="p">:</span> <span class="kt">Float</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">var</span> <span class="nv">increaseSpeed</span><span class="p">:</span> <span class="p">(()</span> <span class="o">-&gt;</span> <span class="p">())?</span>
<span class="p">}</span>
<span class="k">var</span> <span class="nv">myCar</span> <span class="o">=</span> <span class="kt">Car</span><span class="p">()</span>
<span class="n">myCar</span><span class="o">.</span><span class="n">increaseSpeed</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">myCar</span><span class="o">.</span><span class="n">speed</span> <span class="o">+=</span> <span class="mi">30</span> <span class="c1">// The retain cycle occurs here. We cannot use [weak myCar] as myCar is a value type.</span>
<span class="p">}</span>
<span class="n">myCar</span><span class="o">.</span><span class="nf">increaseSpeed</span><span class="p">?()</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"My car's speed :"</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">myCar</span><span class="o">.</span><span class="n">speed</span><span class="p">)</span> <span class="c1">// Prints 30</span>

<span class="k">var</span> <span class="nv">myNewCar</span> <span class="o">=</span> <span class="n">myCar</span>
<span class="n">myNewCar</span><span class="o">.</span><span class="nf">increaseSpeed</span><span class="p">?()</span>
<span class="n">myNewCar</span><span class="o">.</span><span class="nf">increaseSpeed</span><span class="p">?()</span>
<span class="nf">print</span><span class="p">(</span><span class="s">"My new car's speed :"</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">myNewCar</span><span class="o">.</span><span class="n">speed</span><span class="p">)</span> <span class="c1">// Prints 30 still!</span>
</code></pre></div></div>

<p>You would have expected the result of myNewCar to be 90.0, but it prints My new car‚Äôs speed: 30.0</p>

<h2 id="but-why"><strong>But why?</strong></h2>

<p>Well, the reason is, ‚ÄúmyNewCar‚Äù is a partial copy of ‚ÄúnewCar.‚Äù Since closures and their environments cannot be copied completely. The value of ‚Äúspeed‚Äù is copied, but the property ‚ÄúincreaseSpeed‚Äù of ‚ÄúmyNewCar‚Äù (myNewCar.increaseSpeed?()) holds a reference to the ‚ÄúincreaseSpeed‚Äù of ‚ÄúmyCar‚Äù with the ‚Äúspeed‚Äù of ‚ÄúmyCar‚Äù in the captured environment. So, the ‚ÄúincreaseSpeed‚Äù of ‚ÄúmyCar‚Äù is invoked.</p>

<p>These are the various reasons why closures in Swift structs are dangerous.</p>

<h2 id="so-what-do-we-do-now"><strong>So what do we do now?</strong></h2>

<p>The straight forward solution is, avoid using closures in value types. If you want to use them, you should be very careful with it, or else it might lead to unexpected results.
Regarding the retain cycle, the only way to break them is to set the variables ‚ÄúmyCar‚Äù and ‚ÄúmyNewCar‚Äù to nil manually. It doesn‚Äôt sound ideal, but there is no other way.</p>

<p>It was really thought provoking for me when I learnt about the behaviour of closures in value types. I hope you also felt the same.</p>

<p>Enjoyed reading it? Feel free to share your comments below. Like this article? Share it with your friends!
 You can also follow me on twitter right here: <a href="https://twitter.com/rizwanasifahmed">https://twitter.com/rizwanasifahmed</a></p>

<h2 id="references"><strong>References</strong></h2>

<p>[1] <a href="https://forums.swift.org/t/avoiding-unbreakable-reference-cycle-with-value-types-and-closures/18757/6">https://forums.swift.org/t/avoiding-unbreakable-reference-cycle-with-value-types-and-closures/18757/6</a></p>

<p>[2] <a href="https://github.com/Wolox/ios-style-guide/blob/master/rules/avoid-struct-closure-self.md">https://github.com/Wolox/ios-style-guide/blob/master/rules/avoid-struct-closure-self.md</a></p>

<p>[3] <a href="https://www.objc.io/issues/16-swift/swift-classes-vs-structs/">https://www.objc.io/issues/16-swift/swift-classes-vs-structs/</a></p>

<p>[4] <a href="https://marcosantadev.com/capturing-values-swift-closures/">https://marcosantadev.com/capturing-values-swift-closures/</a></p>

<h3 id="more-articles">More articles</h3>

<ul>
  <li><a href="/blog/2020/03/18/using-uicollectionviewcompositionallayout-in-ios-12-and-earlier/">Using UICollectionViewCompositionalLayout in iOS 12 and earlier</a></li>
  <li><a href="/blog/2020/02/13/simulating-remote-push-notifications-in-a-simulator/">Simulating remote push notifications in a simulator</a></li>
  <li><a href="/blog/2019/09/29/swift-5-replaces-introsort-with-timsort-in-the-sort-method/">Swift 5 replaces IntroSort with TimSort in the ‚Äòsort()‚Äô method</a></li>
</ul>
:ET